SELECT SUM(SAL) FROM EMP;
SELECT DEPTNO, SUM(SAL) FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;

SELECT ENAME, SUM(SAL) FROM EMP
GROUP BY ENAME;

#EMP 테이블에 존재하는 직원의 수는?
SELECT COUNT(*) FROM EMP;

#가장 높은 급여와 가장 낮은 급여
SELECT MAX(SAL), MIN(SAL) FROM EMP;

#부서 번호가 20인 사원의 입사일 중 제일 오래된 입사일 출력
SELECT MIN(HIREDATE) 
FROM EMP
WHERE DEPTNO = 20;

#30번 부서 사원들의 평균 급여를 소수점 둘째부터 반올림하시오
SELECT ROUND(AVG(SAL),2) 
FROM EMP 
WHERE DEPTNO = 30;

#부서별 평균급여를 소수점 둘째자리에서 반올림하시오
SELECT DEPTNO, ROUND(AVG(SAL),2)
FROM EMP
GROUP BY DEPTNO;

#부서번호 및 직책별 평균 급여 정렬하기
SELECT DEPTNO, JOB, ROUND(AVG(SAL),2)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

#GROUP BY 절을 사용하여 부서 번호별 평균 추가 수당을 출력해보시오
SELECT DEPTNO, NVL(AVG(COMM),0)
FROM EMP
GROUP BY DEPTNO;

#평균 급여가 2000달러 이상인 부서와 직책은?
SELECT DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000;

#급여가 3000이하 이면서 평균급여가 2000 이상인 부서와 직책
SELECT AVG(SAL), DEPTNO, JOB
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) <= 3000 AND AVG(SAL) >= 2000;

#P212 - Q1
SELECT DEPTNO, ROUND(AVG(SAL),0), MAX(SAL), MIN(SAL), COUNT(*) AS CNT
FROM EMP
GROUP BY DEPTNO;

#P212 - Q2
SELECT JOB, COUNT(*)
FROM EMP
GROUP BY JOB
HAVING COUNT(*) >= 3;

#P213 - Q3
SELECT TO_CHAR(HIREDATE,'YYYY'), DEPTNO, COUNT(*) AS CNT
FROM EMP
GROUP BY TO_CHAR(HIREDATE,'YYYY'), DEPTNO;

#P214 - Q4
SELECT NVL2(COMM,'O','X'), COUNT(*)
FROM EMP
GROUP BY NVL2(COMM,'O','X');

#P215 - Q5
SELECT DEPTNO, TO_CHAR(HIREDATE,'YYYY'), COUNT(*), MAX(SAL),
       SUM(SAL), AVG(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, TO_CHAR(HIREDATE,'YYYY'));

#JOIN 테이블의 결합
SELECT * FROM DEPT;
SELECT ENAME, EMPNO, DEPTNO FROM EMP;

#REAL JOIN  ---> M * N
SELECT * FROM EMP, DEPT;
SELECT COUNT(*) FROM EMP, DEPT;

#여러분이 사용하는 JOIN구문
SELECT EMPNO, ENAME, LOC FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

#EMP 테이블 별칭을 E, DEPT 테이블 별칭을 D 로 하여 EMP 테이블의 사원번호와 DEPT 테이블 부서의 이름이 출력되도록 
SELECT E.EMPNO, DNAME FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO

#등가조인
SELECT EMPNO, ENAME, DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DETNO((NO = D.DEPTNO);

#P239 - Q1
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM DEPT D, EMP E
WHERE SAL > 2000;

#P239 - Q2
SELECT D.DEPTNO, D.DNAME, AVG(E.SAL), MAX(E.SAL), MIN(E.SAL), COUNT(*)
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;

#P239 - Q3
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM DEPT D, EMP E
ORDER BY D.DEPTNO, E.ENAME;

#연습을 위한 테이블
CREATE TABLE DEPT_SEQUENCE
    AS SELECT * FROM DEPT
      WHERE 1 <> 1;

#SEQ 쿼리로 만들기
CREATE SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 10
START WITH 10
MAXVALUE 90
MINVALUE 0
NOCYCLE
CACHE 2;

#테이블 생성 확인
SELECT * FROM DEPT_SEQUENCE;
DESC DEPT_SEQUENCE;

#시퀀스 확인
SELECT * FROM USER_SEQUENCES;

#시퀀스 사용
INSERT INTO DEPT_SEQUENCE (DEPTNO, DNAME, LOC)
VALUES (SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

#시퀀스 번호를 확인하기
SELECT SEQ_DEPT_SEQUENCE.CURRVAL 
FROM DUAL;

# 시퀀스에 값을 넣을 때 SEQ_DEPT_SEQUENCE.NEXTVAL
# 시퀀스는 테이블에 연속된 값을 입력할 때 편함

#시퀀스 수정
ALTER SEQUENCE SEQ_DEPT_SEQUENCE
    INCREMENT BY 3
    MAXVALUE 99
    CYCLE;
    
COMMIT;

#시퀀스 삭제
DROP SEQUENCE SEQ_DEPT_SEQUENCE;
