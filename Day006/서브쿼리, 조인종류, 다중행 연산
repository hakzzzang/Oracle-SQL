SELECT * FROM DEPT;

SELECT * FROM EMP, DEPT;

SELECT E.EMPNO, E.ENAME, D.DEPTNO, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

SELECT * FROM EMP;
SELECT * FROM DEPT;

SELECT D.DEPTNO, D.DNAME, AVG(E.SAL), MAX(E.SAL), MIN(E.SAL), COUNT(*)
FROM EMP E, DEPT D
WHERE D.DEPTNO = E.DEPTNO
GROUP BY D.DEPTNO, D.DNAME;

#급여 범위를 지정하는 조건식으로 조인
SELECT * FROM SALGRADE;
SELECT * FROM EMP;
#비등가 JOIN
SELECT * 
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
#자체 JOIN
SELECT *
FROM EMP E, EMP C
WHERE E.MGR = C.EMPNO;

#8-8
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.MGR;

#외부조인 OUTER JOIN
SELECT * FROM EMP;
SELECT COUNT(*) FROM EMP;
SELECT * FROM EMP WHERE ENAME = 'KING';

#1.일반적 등가 조인
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

#2.LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);

#3.RIGHT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;

#ANSI 표준
#SQL-99
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR,
       E.HIREDATE, E.SAL, E.COMM,
       DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO;

#P234 JOIN-ON
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR,
       E.HIREDATE, E.SAL, E.COMM,
       D.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON (E.DEPTNO=D.DEPTNO)
ORDER BY DEPTNO, E.EMPNO;

#8-14 LEFT OUTER JOIN
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR,
       E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT JOIN EMP E2 ON (E1.MGR = E2.EMPNO);

#8-15 RIGHT OUTER 
SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR,
       E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2 ON (E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

#Q-3
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM DEPT D LEFT JOIN EMP E ON (D.DEPTNO = E.DEPTNO);

#Q-4
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL,
       E1.DEPTNO AS DEPTNO_1, E1.MGR, E1.ENAME
FROM DEPT D LEFT JOIN EMP E ON(D.DEPTNO = E.DEPTNO)
    LEFT JOIN EMP E1 ON(E.MGR = E1.EMPNO)
    LEFT JOIN SALGRADE S ON(E1.SAL BETWEEN S.LOSAL AND S.HISAL)
ORDER BY D.DEPTNO, E.EMPNO;
     

SELECT E1.DEPTNO, S.LOSAL, S.HISAL, S.GRADE, E1.MGR AS MGR_EMPNO, E1.ENAME AS MGR_ENAME
FROM EMP E1 JOIN SALGRADE S ON(E1.SAL BETWEEN S.LOSAL AND S.HISAL);

#서브쿼리
#사원 이름이 'JONES'인 사원 급여 출력
SELECT SAL FROM EMP
WHERE ENAME = 'JONES';

#급여가 2975보다 높은 사원 정보 출력
SELECT * FROM EMP
WHERE SAL > 2975;

#급여가 'JONES'보다 높은 사원의 정보 출력
SELECT ENAME, SAL FROM EMP
WHERE SAL > (SELECT SAL
             FROM EMP
             WHERE ENAME = 'JONES');
             
#'KING'보다 급여가 많은 사람???
SELECT ENAME, SAL FROM EMP
WHERE SAL > (SELECT SAL
             FROM EMP
             WHERE ENAME = 'KING');
             
#EMP 테이블의 사원 정보 중에서 사원 이름이 ALLEN인 사원의 추가 수당보다 많이 받는 사원 정보 출력
SELECT *
FROM EMP
WHERE COMM > (SELECT COMM
             FROM EMP
             WHERE ENAME = 'ALLEN');
             
#9-4 서브쿼리의 결과 값이 날짜형인 경우
#'ALLEN'보다 입사일이 빠른 직원은
SELECT HIREDATE, ENAME FROM EMP
WHERE HIREDATE < (SELECT HIREDATE
                  FROM EMP
                  WHERE ENAME = 'ALLEN');

#9-5 JOIN 구문에서도 SUBQUERY가 동작할까??
#평균급여보다 많이 받는 직원들의 정보는???
#단, 부서는 20번 번호만 조회해라
SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL,
       D.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON(D.DEPTNO = E.DEPTNO AND E.SAL >(SELECT AVG(SAL) FROM EMP) AND D.DEPTNO = 20);

#다중행 연산자
# IN 메인쿼리의 데이터가 서브쿼리의 결과 중 하나라도 일치한 데이터가 있다면 TRUE
# ANY, SOME 메인쿼리의 조건식을 만족하는 서브쿼리의 결과가 하나 이상이면 TRUE
# ALL 메인쿼리의 조건식을 서브쿼리의 결과 모두가 만족하면 TRUE
# EXISTS 서브쿼리의 결과가 존재하면(즉, 행이 1개 이상일경우) TRUE
# 실행 결과가 여러개인 쿼리를 확인합니다.

SELECT * FROM EMP
WHERE DEPTNO IN (20, 30);

#각 부서별 최고 급여와 동일한 급여를 받는 사원정보 출력
SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO;

SELECT * FROM EMP
WHERE SAL IN (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

# ANY를 사용해보자!
SELECT * FROM EMP
WHERE SAL = ANY (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

# SOME을 사용해보자!
SELECT * FROM EMP
WHERE SAL = SOME (SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

#ANY 30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원정보 출력
SELECT SAL FROM EMP WHERE DEPTNO = 30;

#ANY는 하나라도 만족하면 다 출력함.
SELECT * FROM EMP 
WHERE SAL < ANY (SELECT SAL FROM EMP WHERE DEPTNO = 30)
ORDER BY SAL, EMPNO;

# 9-14 ALL
# 30번 부서번호인 사원들의 최소 급여보다 더 적은 급여를 받는
# ALL이니까 모든 조건을 만족해야함,
# 그말은 즉 950보다 작은 급여인 사람이 출력되야함
SELECT * FROM EMP 
WHERE SAL < ALL(SELECT SAL FROM EMP WHERE DEPTNO = 30);

#EXISTS 연산자
#서브쿼리에 값이 존재하는 경우!!!
SELECT DNAME FROM DEPT WHERE DEPTNO = 10;
#EMP테이블에 회계부서가 존재하는가???
SELECT * FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 10);

#없는 50번 부서 문의??
SELECT * FROM EMP
WHERE EXISTS (SELECT DNAME FROM DEPT WHERE DEPTNO = 50);

#비교할 열이 여러 개인 다중열 서브쿼리
# QUIZ 문제
SELECT * FROM EMP
WHERE (DEPTNO, SAL) IN (SELECT DEPTNO, MAX(SAL) 
                        FROM EMP
                        GROUP BY DEPTNO);

#Q1
SELECT E.JOB, E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D ON(D.DEPTNO = E.DEPTNO)
WHERE JOB = (SELECT JOB FROM EMP WHERE ENAME = 'ALLEN'); 

#Q2
#SQL-99 Ver

SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
     JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S.HISAL)
WHERE E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY SAL DESC, EMPNO;

#Ansi 표준
SELECT E.EMPNO, E.ENAME, D.DNAME, E.HIREDATE, D.LOC, E.SAL, S.GRADE
FROM EMP E, DEPT D, SALGRADE S
WHERE (E.DEPTNO = D.DEPTNO) AND 
      (E.SAL BETWEEN S.LOSAL AND HISAL) AND
      (E.SAL > (SELECT AVG(SAL) FROM EMP));
      

